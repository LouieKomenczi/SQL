
/*Rollback */

/*1- Deleting a sales order. First we need to delete all the details from the order, after this we check that we have not left any order details, 
in case all ok we procede with deleting the order header. If we fail to delete the order details we roll back the transactions.*/
USE AdventureWorksLT2012 


DECLARE @OrderID INT = 71783;
 
BEGIN TRAN DeleteOrder;
DELETE FROM SalesLT.SalesOrderDetail WHERE SalesOrderID = @OrderID;
IF (SELECT COUNT(*)FROM SalesLT.SalesOrderDetail WHERE SalesOrderID = @OrderID) >0
	BEGIN
		ROLLBACK TRAN DeleteOrder
		PRINT 'Delete failed'
	END
ELSE
	BEGIN
		DELETE FROM SalesLT.SalesOrderHeader WHERE SalesOrderID = @OrderID;
		COMMIT TRAN DeleteOrder;
		PRINT 'Delete completed'
	END	


/*2.Next transaction, will update a special offer to 25% and add a new product to this offer.
The update and insert commands are included in a try catch and a transaction so we can roll back if error occures.*/
USE AdventureWorks2016

BEGIN TRY
	BEGIN TRAN SpecialOffer
		UPDATE Sales.SpecialOffer SET DiscountPct = 0.25 WHERE SpecialOfferID = 6;
		INSERT INTO Sales.SpecialOfferProduct (SpecialOfferID, ProductID)
			VALUES (6, 900)
		COMMIT TRAN SpecialOffer
		PRINT 'Discount updated!'
END TRY
BEGIN CATCH
	ROLLBACK TRAN SpecialOffer
	PRINT 'Discount not updated!'
END CATCH



/*3. - the transaction below does an insert in Address table. If the city is allready present, the transaction will be rolled back with message to user.
If the city is present only one time after inser, transaction will be commited and user informed.*/

USE AdventureWorksLT2012 

DECLARE @Counter INT

BEGIN TRAN AddCategory

INSERT INTO SalesLT.Address(AddressLine1,City,StateProvince,CountryRegion,PostalCode)
VALUES ('River road','Sligo','Connacht','Ireland','F91P3L5')

SELECT @Counter = COUNT(*) FROM SalesLT.Address WHERE City = 'Sligo'

IF @Counter > 1 
	BEGIN
		ROLLBACK TRAN AddCategory
		PRINT 'City allready present in db'
	END
ELSE
	BEGIN
		COMMIT TRAN AddCategory
		PRINT 'City added to db'
	END



/*4. - Next transactions will try to insert a model with description in to our database. First a try catch block is used to insert the model.
If the model allready exists we catch the error that would be generated by the duplicate entry. The DEscritionID variable stores the relevant key.
To insert the descrition we use an IF statement to test if we have this info allready. If the info is not there we insert it. 
Then we assign the DescritionID value to the variable. 
With an IF statement we check if we have the ModelID and DescriptionID so we can do insert in the table that links them.
If any of the above are inexistent we roll back the transaction so we do not have a model or descrition created by themselves.
We use a try catch block again to prevent errors if the row we try to insert is allready present. 
In case it is we roll back and inform the user.*/

DELETE FROM SalesLT.ProductModelProductDescription WHERE ProductModelID= 151
DELETE FROM SalesLT.ProductModel WHERE Name = 'Tools'
DELETE FROM SalesLT.ProductDescription WHERE Description = 'Multi tool for bikes'

USE AdventureWorksLT2012


BEGIN TRAN InsertTool

DECLARE @DescriptionID INT;
DECLARE @ModelID INT;
	BEGIN TRY			
		INSERT INTO SalesLT.ProductModel(Name) VALUES('Tools');
		Select @ModelID=ProductModelID FROM SalesLT.ProductModel WHERE Name = 'Tools';		
	END TRY
	BEGIN CATCH 
		Select @ModelID=ProductModelID FROM SalesLT.ProductModel WHERE Name = 'Tools';		
	END CATCH	
	IF (SELECT COUNT(*)FROM SalesLT.ProductDescription WHERE Description = 'Multi tool for bikes' )	=0	
		INSERT INTO SalesLT.ProductDescription(Description) VALUES('Multi tool for bikes')
	Select @DescriptionID=ProductDescriptionID FROM SalesLT.ProductDescription WHERE Description = 'Multi tool for bikes';
	IF (@ModelID IS NOT NULL) AND (@DescriptionID IS NOT NULL)
	BEGIN
		BEGIN TRY
			INSERT INTO SalesLT.ProductModelProductDescription(ProductModelID,ProductDescriptionID,Culture ) VALUES (@ModelID,@DescriptionID,'en')
			COMMIT TRAN InsertTool;
			PRINT 'Insert was succesfull'
		END TRY
		BEGIN CATCH 
			ROLLBACK TRAN InsertTool;
			PRINT 'Item allready exists'
		END CATCH
	END	
	ELSE
	BEGIN 
		ROLLBACK TRAN InsertTool;
		PRINT 'Insert was not succesfull'
	END

/*5. Deleting the above entries. Since the tables are linked they cannot be deleted independet of eachother, as this would create inconsistency.
First we try to delete the entry in the ProductModelProductDescrition table, as this is the table linking the model and the descrition.
We set the delete in a try catch, if any of the delete fails for whatever reason the catch will roll back the transaction. 
The variable is used to find the correct key for model name Tools */

BEGIN TRAN DelTools
	DECLARE @ModID INT;
	SELECT @ModID = ProductModelId FROM SalesLT.ProductModel WHERE Name = 'Tools';
	BEGIN TRY		
		DELETE FROM SalesLT.ProductModelProductDescription WHERE ProductModelID= @ModID;
		DELETE FROM SalesLT.ProductModel WHERE Name = 'Tools'
		DELETE FROM SalesLT.ProductDescription WHERE Description = 'Multi tool for bikes'
		COMMIT TRAN DelTools
	END TRY		
	BEGIN CATCH
		ROLLBACK TRAN DelTools;
		PRINT 'Delet not successfull'
	END CATCH


/*6. Employee promoted with a pay rate change into payhistory table. 
For this Transaction I have created 3 variables that store the values waiting to be inserted. To catch any errors we use a TRY that incorporates
the Transaction PayChange. After the Insert command we inform the user that the transaction was done. 
If an error pops up, we catch it roll back the transaction and */

USE AdventureWorks2016;

DECLARE @BussinessID INT = 12;
DECLARE @PayRate MONEY = 27.00;
DECLARE @PayFrec TINYINT = 2;
BEGIN TRY
	BEGIN TRAN PayChange
		UPDATE HumanResources.Employee SET JobTitle = 'Senior Tool Designer' WHERE BusinessEntityID = @BussinessID
		INSERT INTO HumanResources.EmployeePayHistory (BusinessEntityID, RateChangeDate,Rate, PayFrequency)
		VALUES (@BussinessID, GETDATE(), @PayRate, @PayFrec)		
	COMMIT TRAN PayChange
	PRINT 'Role changed and Pay change inserted!'
END TRY
BEGIN CATCH
	ROLLBACK TRAN PayChange
	PRINT 'Operation was not successfull, check values inserted!'
END CATCH
	

/*7.Nested transactions 
For the next example I have created a stored procedure that would delete an employee from DB.
First we have to disable the trigger that would prevent the deletion of an employee, this will be enabled at the end of the procedure.
Then we declare 2 variables, one for keeping the BussinesEntityID, this will identify the same person throughout all the tables we need to 
delete data. Second var just keeps the name to have a more user friendly feedback on our messages.
After we capture the 2 variables with selects, we test with and IF if we have the person in the DB. 
Then we begin a TRY that would contain the two nested Transactions. First Tran deletes the Employee, if successful goes to second Tran that would 
delete the Person. If this is succesfull commits the second trans, at this point we have succesfully deleted the employee and the person from DB.
If any of the operations fail we catch it in CATCH block and roll back and inform the user.*/

USE AdventureWorks2016;
DROP PROCEDURE DeleteEmployee;

CREATE PROCEDURE DeleteEmployee AS
BEGIN
	DISABLE TRIGGER dEmployee ON HumanResources.Employee;
	DECLARE @DeleteID INT;
	DECLARE @DeleteName VARCHAR(50);
	SELECT @DeleteID = BusinessEntityID FROM Person.Person 
		WHERE LastName = 'Glimp' AND FirstName = 'Diane' AND MiddleName = 'R';	
	SELECT @DeleteName = FirstName+' '+MiddleName+' '+LastName  FROM Person.Person WHERE BusinessEntityID = @DeleteID;
	IF @DeleteID  IS NULL PRINT 'Person was not found in DB!'
	ELSE
	BEGIN
		BEGIN TRY
			BEGIN TRAN DelEmp;
				DELETE FROM HumanResources.EmployeeDepartmentHistory WHERE BusinessEntityID = @DeleteID;
				DELETE FROM HumanResources.EmployeePayHistory WHERE BusinessEntityID = @DeleteID;
				DELETE FROM HumanResources.Employee WHERE BusinessEntityID = @DeleteID;				
				BEGIN TRAN DelPerson;
					DELETE FROM Person.PersonPhone WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.Password WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.EmailAddress WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.Person WHERE BusinessEntityID = @DeleteID;					
				COMMIT TRAN DelPerson;		
				PRINT @DeleteName+' person was deleted successfully!'		
			COMMIT TRAN DelEmp
			PRINT @DeleteName+' employee was deleted successfully!'
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN;
			PRINT @DeleteName + ' was not Deleted '
		END CATCH;
	END;
	ENABLE TRIGGER dEmployee ON HumanResources.Employee;
END;

/*8. Save Point
I have modified the above stored procedure so we can delete employee independent of person. For this we use a savepoint and a BIT variable.
The procedure pickes up data and uses delet as before however we do not have a nested transaction. The Save Point sits between the delete comands 
for employee and person. In case we fail to delete the person info, we are not setting our PersonDeleted variable to 1. This will be picked up in 
CATCH and we roll back to out save point and commit the transaction done up to here, (delet for employee).
In case we have no error transaction proceeds as above and deletes both employee and person.
The PRINT command informs user if both person and employee were deleted or we have only a partial delete.
To test the partial delete I have commented out the first DELETE command from person, hence causing an error because of key constrain.

*/
DROP PROCEDURE DeleteEmployeeAndPerson;

CREATE PROCEDURE DeleteEmployeeAndPerson AS
BEGIN
	DISABLE TRIGGER dEmployee ON HumanResources.Employee;
	DECLARE @DeleteID INT;
	DECLARE @DeleteName VARCHAR(50);
	DECLARE @PersonDeleted BIT = 0; 
	SELECT @DeleteID = BusinessEntityID FROM Person.Person 
		WHERE LastName = 'Miller' AND FirstName = 'Dylan' AND MiddleName = 'A';	
	SELECT @DeleteName = FirstName+' '+MiddleName+' '+LastName  FROM Person.Person WHERE BusinessEntityID = @DeleteID;
	IF @DeleteID  IS NULL PRINT 'Person was not found in DB!'
	ELSE
	BEGIN
		BEGIN TRY
			BEGIN TRAN DelEmp;
				DELETE FROM HumanResources.EmployeeDepartmentHistory WHERE BusinessEntityID = @DeleteID;
				DELETE FROM HumanResources.EmployeePayHistory WHERE BusinessEntityID = @DeleteID;
				DELETE FROM HumanResources.Employee WHERE BusinessEntityID = @DeleteID;		
				SAVE TRAN DelEmp;			
					DELETE FROM Person.PersonPhone WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.Password WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.EmailAddress WHERE BusinessEntityID = @DeleteID;
					DELETE FROM Person.Person WHERE BusinessEntityID = @DeleteID;	
					SELECT @PersonDeleted = 1;					
				PRINT @DeleteName+' person was deleted successfully!'		
			COMMIT TRAN DelEmp
			PRINT @DeleteName+' employee was deleted successfully!'
		END TRY
		BEGIN CATCH
			IF (@PersonDeleted = 0) 
			BEGIN
				ROLLBACK TRAN DelEmp;
				COMMIT TRAN;
				PRINT 'Partial Delete! ' +@DeleteName + 'was deleted only from the employee tables, person still available!'
			END;			
			ELSE
			BEGIN
				ROLLBACK TRAN;
				PRINT @DeleteName + ' person and employee was not Deleted!'
			END;
			
		END CATCH;
	END;
	ENABLE TRIGGER dEmployee ON HumanResources.Employee;
END;


/*dirty reads - retreiving information that is updated but not commited. 
In order to avoid this we set transation isolation to read commited(this is the default level) .
 */
USE AdventureWorks2016;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN TRAN
	SELECT * FROM Sales.CurrencyRate 
	WHERE YEAR(ModifiedDate) > 2013 AND ToCurrencyCode = 'JPY';
COMMIT TRAN;


/*lost updates - if another transaction is updating the same row at the same time. 
The folowing will prevent lost updates*/
 
USE AdventureWorks2016;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ ;
BEGIN TRAN
	UPDATE Sales.CurrencyRate 
	SET EndOfDayRate = 124.419 
	WHERE ModifiedDate = '2014-01-01' AND ToCurrencyCode = 'JPY';
COMMIT TRAN;


/*phantom reads -  this happens when rows are inserted after a select and will be visible in a folowup select in 
the same transaction. The below will prevent phantom reads.*/
USE AdventureWorks2016;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRAN
	SELECT * FROM Purchasing.PurchaseOrderDetail 
	WHERE PurchaseOrderID = 8;
COMMIT TRAN








